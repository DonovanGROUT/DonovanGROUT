name: ğŸ”„ Auto-update README

on:
  schedule:
    # ExÃ©cuter toutes les 3 heures
    - cron: '0 */3 * * *'
  workflow_dispatch:
    # Permet l'exÃ©cution manuelle

jobs:
  update-readme:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
      
    - name: Update README with latest project
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        USERNAME: ${{ github.repository_owner }}
      run: |
        # Variables pour l'horodatage
        export TIMESTAMP=$(date '+%d/%m/%Y %H:%M UTC')
        
        # Fonction pour rÃ©cupÃ©rer le lien de dÃ©ploiement depuis le README d'un projet
        get_deployment_link() {
          local username="$1"
          local repo_name="$2"
          
          >&2 echo "ğŸ” Recherche du lien de dÃ©ploiement pour $repo_name..."
          
          # Cas spÃ©cial pour le profil GitHub
          if [ "$repo_name" = "DonovanGROUT" ]; then
            >&2 echo "   ğŸŒŸ Cas spÃ©cial dÃ©tectÃ©: Profil GitHub"
            echo "https://github.com/$username"
            return 0
          fi
          
          # Essayer diffÃ©rents noms de fichiers README
          for readme_file in "README.md" "readme.md" "README.MD" "readme.MD"; do
            readme_url="https://raw.githubusercontent.com/$username/$repo_name/main/$readme_file"
            
            # TÃ©lÃ©charger le README
            readme_content=$(curl -s "$readme_url")
            
            if [[ -n "$readme_content" ]]; then
              # PRIORITÃ‰ 1 : Chercher les balises de commentaire dÃ©diÃ©es
              for pattern in "DEPLOY-LINK-START" "DEPLOYMENT-URL-START" "DEMO-LINK-START" "LIVE-DEMO-START" "PROJECT-URL-START"; do
                # VÃ©rifier d'abord si les balises existent
                if echo "$readme_content" | grep -q "<!-- $pattern -->"; then
                  >&2 echo "   ğŸ·ï¸ Balises $pattern dÃ©tectÃ©es"
                  # Chercher un lien dans ces balises
                  if deploy_link=$(echo "$readme_content" | grep -oP "<!-- $pattern -->(.*?)<!-- .*?-END -->" | sed 's/<!-- [^>]* -->//g' | grep -oE 'https?://[^[:space:]")\`]+' | head -1); then
                    if [[ -n "$deploy_link" ]]; then
                      >&2 echo "   ğŸ¯ Lien trouvÃ© via balise $pattern: $deploy_link"
                      echo "$deploy_link"
                      return 0
                    fi
                  fi
                  # Si les balises existent mais ne contiennent pas de lien, on s'arrÃªte ici
                  >&2 echo "   âœ‹ Balises $pattern trouvÃ©es mais pas de lien de dÃ©ploiement dÃ©fini"
                  echo ""
                  return 0
                fi
              done
              
              # PRIORITÃ‰ 2 : Chercher les liens en contexte (aprÃ¨s des mots-clÃ©s spÃ©cifiques)
              for keyword in "dÃ©mo" "demo" "live" "deployment" "dÃ©ploiement" "deployed" "dÃ©ployÃ©" "site" "app" "application"; do
                if deploy_link=$(echo "$readme_content" | grep -i -B1 -A2 "$keyword" | grep -oE 'https?://[^[:space:]")\`]+' | grep -v 'github.com/[^/]+/[^/]+$' | head -1); then
                  if [[ -n "$deploy_link" ]]; then
                    >&2 echo "   ğŸ” Lien trouvÃ© via mot-clÃ© '$keyword': $deploy_link"
                    echo "$deploy_link"
                    return 0
                  fi
                fi
              done
              
              # PRIORITÃ‰ 3 : Accepter les liens GitHub spÃ©cifiques (ex: pages GitHub)
              if deploy_link=$(echo "$readme_content" | grep -oE 'https?://[^[:space:]")\`]+\.github\.io/[^[:space:]")\`]+'); then
                >&2 echo "   ğŸ” Lien GitHub Pages trouvÃ©: $deploy_link"
                echo "$deploy_link"
                return 0
              fi
              
              # PRIORITÃ‰ 4 : Liens de dÃ©ploiement populaires (Netlify, Vercel, Heroku, etc.)
              if deploy_link=$(echo "$readme_content" | grep -oE 'https?://[^[:space:]")\`]+\.(netlify\.app|vercel\.app|herokuapp\.com|railway\.app|render\.com)'); then
                >&2 echo "   ğŸš€ Lien de plateforme de dÃ©ploiement trouvÃ©: $deploy_link"
                echo "$deploy_link"
                return 0
              fi
            fi
          done
          
          echo ""
        }
        
        # Fonction pour rÃ©cupÃ©rer les technologies utilisÃ©es dans le projet
        get_tech_stack() {
          local username="$1"
          local repo_name="$2"
          
          >&2 echo "ğŸ§° Recherche des technologies utilisÃ©es pour $repo_name..."
          
          # Cas spÃ©cial pour le profil GitHub
          if [ "$repo_name" = "DonovanGROUT" ]; then
            >&2 echo "   ğŸŒŸ Cas spÃ©cial dÃ©tectÃ©: Profil GitHub"
            echo "Markdown, YAML, GitHub Actions"
            return 0
          fi
          
          # RÃ©cupÃ©rer les langages via l'API
          languages_json=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/$username/$repo_name/languages")
          
          # VÃ©rifier si des langages ont Ã©tÃ© trouvÃ©s
          if [ -n "$languages_json" ] && [ "$languages_json" != "{}" ] && [ "$languages_json" != "null" ]; then
            # Lister les langages (top 3 seulement)
            formatted_langs=$(echo "$languages_json" | jq -r 'keys | [.[0:3][] | select(.)] | join(", ")')
            
            if [ -n "$formatted_langs" ]; then
                >&2 echo "   ğŸ’» Technologies dÃ©tectÃ©es via API: $formatted_langs"
                echo "$formatted_langs"
                return 0
            fi
          fi
          
          >&2 echo "   âš ï¸ Aucune technologie dÃ©tectÃ©e via l'API, recherche dans README..."
          
          # Essayer diffÃ©rents noms de fichiers README
          for readme_file in "README.md" "readme.md" "README.MD" "readme.MD"; do
            readme_url="https://raw.githubusercontent.com/$username/$repo_name/main/$readme_file"
            
            # TÃ©lÃ©charger le README
            readme_content=$(curl -s "$readme_url")
            
            if [[ -n "$readme_content" ]]; then
              # Chercher des patterns de technologies dans le README
              tech_pattern="[Tt]ech[s]?:.*|[Tt]echnologies:.*|[Ss]tack:.*|[Dd]Ã©veloppÃ© avec:.*|[Dd]eveloped with:.*|[Bb]uilt with:.*"
              techs=$(echo "$readme_content" | grep -oP "$tech_pattern" | head -1 | sed -E 's/[Tt]ech[s]?:|[Tt]echnologies:|[Ss]tack:|[Dd]Ã©veloppÃ© avec:|[Dd]eveloped with:|[Bb]uilt with://g' | xargs)
              
              if [[ -n "$techs" ]]; then
                >&2 echo "   ğŸ“¦ Technologies trouvÃ©es dans README: $techs"
                echo "$techs"
                return 0
              fi
            fi
          done
          
          echo "Non spÃ©cifiÃ©"
        }

        # RÃ©cupÃ©rer le dernier repository public (non forkÃ©)
        echo "ğŸ” RÃ©cupÃ©ration du dernier repository public..."
        LATEST_REPO=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
          "https://api.github.com/users/$USERNAME/repos?sort=created&direction=desc&per_page=20&type=public" | \
          jq -r 'map(select(.fork == false and .private == false)) | .[0]')
        
        if [ "$LATEST_REPO" = "null" ]; then
          echo "âš ï¸ Aucun repository public trouvÃ©"
          export REPO_NAME="Aucun projet public"
          export REPO_URL="https://github.com/$USERNAME"
          export REPO_DESC="Aucun repository public trouvÃ©"
          export REPO_TECHS="Non spÃ©cifiÃ©"
          export REPO_STARS="0"
          export REPO_FORKS="0"
          export REPO_DATE="N/A"
          export DEPLOY_LINK=""
        else
          # Extraire les informations du projet
          export REPO_NAME=$(echo "$LATEST_REPO" | jq -r '.name // "Repository"')
          export REPO_URL=$(echo "$LATEST_REPO" | jq -r '.html_url // "https://github.com/'$USERNAME'"')
          export REPO_DESC=$(echo "$LATEST_REPO" | jq -r '.description // "Aucune description disponible"')
          export REPO_STARS=$(echo "$LATEST_REPO" | jq -r '.stargazers_count // 0')
          export REPO_FORKS=$(echo "$LATEST_REPO" | jq -r '.forks_count // 0')
          export REPO_DATE=$(echo "$LATEST_REPO" | jq -r '.created_at' | cut -d'T' -f1)
          
          # RÃ©cupÃ©rer les technologies utilisÃ©es
          export REPO_TECHS=$(get_tech_stack "$USERNAME" "$REPO_NAME")
          
          # RÃ©cupÃ©rer le lien de dÃ©ploiement s'il existe
          export DEPLOY_LINK=$(get_deployment_link "$USERNAME" "$REPO_NAME")
          
          echo "âœ… Repository trouvÃ©: $REPO_NAME"
          echo "ğŸ”— Lien de dÃ©ploiement trouvÃ©: ${DEPLOY_LINK:-Aucun}"
        fi
        
        # Sauvegarder le README original
        cp README.md README.md.backup
        
        # CrÃ©er le script Python comme dans le workflow
        cat > update_readme.py << 'EOF'
        import re
        import sys
        import os

        def update_section(content, start_marker, end_marker, new_content):
            pattern = f'({re.escape(start_marker)})(.*?)({re.escape(end_marker)})'
            replacement = f'\\1\n{new_content}\n\\3'
            return re.sub(pattern, replacement, content, flags=re.DOTALL)
        
        def format_stats_line(techs, stars, forks, is_french=True):
            # Conversion des variables pour vÃ©rification
            try:
                stars_int = int(stars)
                forks_int = int(forks)
            except (ValueError, TypeError):
                stars_int = 0
                forks_int = 0
            
            # PrÃ©fixe de la ligne selon la langue
            prefix = "**Techs:**" if is_french else "**Techs:**"
            
            # Construction de la ligne de statistiques
            stats_line = f"{prefix} {techs}"
            
            # Ajout des stars uniquement si > 0
            if stars_int > 0:
                stats_line += f" | **â­ Stars:** {stars}"
                
            # Ajout des forks uniquement si > 0
            if forks_int > 0:
                stats_line += f" | **ğŸ”€ Forks:** {forks}"
                
            return stats_line

        # Lire le README
        with open('README.md', 'r', encoding='utf-8') as f:
            readme_content = f.read()

        # RÃ©cupÃ©rer les variables d'environnement
        repo_name = os.getenv('REPO_NAME', 'Unknown')
        repo_url = os.getenv('REPO_URL', 'https://github.com')
        repo_desc = os.getenv('REPO_DESC', 'No description')
        repo_techs = os.getenv('REPO_TECHS', 'Non spÃ©cifiÃ©')
        repo_stars = os.getenv('REPO_STARS', '0')
        repo_forks = os.getenv('REPO_FORKS', '0')
        repo_date = os.getenv('REPO_DATE', 'Unknown')
        timestamp = os.getenv('TIMESTAMP', 'Unknown')
        deploy_link = os.getenv('DEPLOY_LINK', '')
        
        # Formatage conditionnel des statistiques
        fr_stats_line = format_stats_line(repo_techs, repo_stars, repo_forks, is_french=True)
        en_stats_line = format_stats_line(repo_techs, repo_stars, repo_forks, is_french=False)
        
        # Lien de dÃ©ploiement conditionnel
        deploy_fr = f"\n\nâ¡ï¸ [Voir le projet dÃ©ployÃ©]({deploy_link})" if deploy_link else ""
        deploy_en = f"\n\nâ¡ï¸ [See deployed project]({deploy_link})" if deploy_link else ""

        # Contenu pour la section franÃ§aise
        fr_content = f"""### ğŸ”¥ Mon dernier projet public

        [![GitHub](https://img.shields.io/badge/GitHub-181717?style=for-the-badge&logo=github&logoColor=white)]({repo_url})

        **[{repo_name}]({repo_url})** - CrÃ©Ã© le {repo_date}

        {repo_desc}

        {fr_stats_line}{deploy_fr}"""

        # Contenu pour la section anglaise  
        en_content = f"""### ğŸ”¥ My latest public project

        [![GitHub](https://img.shields.io/badge/GitHub-181717?style=for-the-badge&logo=github&logoColor=white)]({repo_url})

        **[{repo_name}]({repo_url})** - Created on {repo_date}

        {repo_desc}

        {en_stats_line}{deploy_en}"""

        # Contenu pour les timestamps
        fr_timestamp = f"""---
        *ğŸ”„ Ce profil est mis Ã  jour automatiquement - DerniÃ¨re mise Ã  jour : {timestamp}*"""

        en_timestamp = f"""---
        *ğŸ”„ This profile is automatically updated - Last update: {timestamp}*"""

        # Mettre Ã  jour chaque section
        print("ğŸ”„ Mise Ã  jour de la section franÃ§aise du projet...")
        readme_content = update_section(readme_content, 
            '<!-- AUTO-UPDATE: LATEST-PROJECT-FR-START -->',
            '<!-- AUTO-UPDATE: LATEST-PROJECT-FR-END -->',
            fr_content)

        print("ğŸ”„ Mise Ã  jour de la section anglaise du projet...")
        readme_content = update_section(readme_content,
            '<!-- AUTO-UPDATE: LATEST-PROJECT-EN-START -->', 
            '<!-- AUTO-UPDATE: LATEST-PROJECT-EN-END -->',
            en_content)

        print("ğŸ”„ Mise Ã  jour du timestamp franÃ§ais...")
        readme_content = update_section(readme_content,
            '<!-- AUTO-UPDATE: TIMESTAMP-FR-START -->',
            '<!-- AUTO-UPDATE: TIMESTAMP-FR-END -->', 
            fr_timestamp)

        print("ğŸ”„ Mise Ã  jour du timestamp anglais...")
        readme_content = update_section(readme_content,
            '<!-- AUTO-UPDATE: TIMESTAMP-EN-START -->',
            '<!-- AUTO-UPDATE: TIMESTAMP-EN-END -->',
            en_timestamp)

        # Ã‰crire le nouveau README
        with open('README.md', 'w', encoding='utf-8') as f:
            f.write(readme_content)

        print(f'âœ… README mis Ã  jour avec le projet: {repo_name}')
        print(f'ğŸ“Š Timestamp: {timestamp}')
        EOF
        
        # ExÃ©cuter le script Python
        echo "ğŸ ExÃ©cution du script Python de mise Ã  jour..."
        python3 update_readme.py
        
        # Nettoyer
        rm -f update_readme.py
        
    - name: Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add README.md
        if git diff --staged --quiet; then
          echo "â„¹ï¸ Aucun changement dÃ©tectÃ© dans le README"
        else
          git commit -m "ğŸ”„ Auto-update README with latest project: $(date '+%Y-%m-%d %H:%M')"
          git push
          echo "âœ… README mis Ã  jour et poussÃ© vers GitHub"
        fi
